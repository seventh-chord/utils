<html>
<head>
  <meta charset="UTF-8">
  <title>CRCs</title>

  <style>
    h1 {
      font-size: 24px;
    }
    h2 {
      padding-top: 20px;
      font-size: 20px;
    }


    .bad {
      border-color: red;
      outline-color: red;
    }

    .code {
      font-style: normal;
      font-family: monospace;
      padding: 4px;
      background: #ddf;
      border-radius: 4px;
    }

    .note {
      font-style: italic;
      font-size: 90%;
    }

    input {
      text-align: right;
      width: 10em;
    }

    td {
      padding-top: 5px;
      padding-bottom: 5px;
      padding-left: 3px;
      padding-right: 3px;
    }

    #table_common_polynomials tr {
      cursor: pointer;
    }
    #table_common_polynomials td:nth-child(3) {
      text-align: center;
    }
    #table_common_polynomials td {
      padding: 10px;
    }
  </style>
</head>
<body>
<h1>Cyclic redundancy checks</h1>

<p><b>TODO</b> also learn about other common checksums, like Adler32 and fnv1-a</p>
<p><b>TODO</b> write some notes about the properties of CRCs</p>
<p><b>TODO</b> shift-register representation of CRCs?</p>
<p><b>TODO</b> using special instructions to compute CRCs</p>
<p><b>TODO</b> table-driven approach?</p>
<p><b>TODO</b> final XOR step in some variants?</p>
<p><b>TODO</b> do some variants start with ones instead of zeros?</p>
<p><b>TODO</b> bit- and byte-order in commonly used implementations?</p>
<p><b>TODO</b> watch <a href="https://betterembsw.blogspot.com/2013/11/crc-webinar.html">https://betterembsw.blogspot.com/2013/11/crc-webinar.html</a></p>
<p><b>TODO</b> read <a href="http://www.ross.net/crc/download/crc_v3.txt">http://www.ross.net/crc/download/crc_v3.txt</a></p>

<div>
  <h2>Polynomial</h2>
  <table>
    <tr>
      <td>Normal</td>
      <td><input id="field_normal" type="text"></td>
      <td><span class="note">If the bit with value 2<sup>n</sup> is set, the polynomial contains x<sup>n</sup>. x<sup>N</sup> is implicit.</span></td>
    </tr>
    <tr>
      <td>Reverse</td>
      <td><input id="field_reverse" type="text"></td>
      <td><span class="note">If the bit with value 2<sup>n</sup> is set, the polynomial contains x<sup>N - n - 1</sup>. x<sup>N</sup> is implicit.</span></td>
    </tr>
    <tr>
      <td>Koopman</td>
      <td><input id="field_reciprocal" type="text"></td>
      <td><span class="note">If the bit with value 2<sup>n</sup> is set, the polynomial contains x<sup>n + 1</sup>. x<sup>0</sup> is implicit.</span></td>
    </tr>
    <tr>
      <td>Width (N)</td>
      <td><input id="field_width" type="number" value=3></td>
    </tr>
    <tr>
      <td>Polynomial</td>
      <td colspan=2><span id="span_polynomial" class="code"></span></td>
    </tr>
  </table>

  <p>This degree <span id="span_polynomial_degree" class="code"></span> polynomial will generate a <span id="span_crc_width" class="code"></span> bit CRC.</p>

  <p>
    The MSB of the polynomial must be 1, otherwise the computation doesn't work.<br>
    Trailing (LSB) zeros in the polynomial lead to an equal number of trailing unused bits in the CRC.
  </p>

  <p>The polynomial form is usefull since it is consistent, even if different formats for converting the polynomial to a number.</p>
</div>

<div>
  <h2>Common polynomials</h2>

  <p class="note">Click an entry to show it in the view above!</p>

  <table id="table_common_polynomials">
    <tr><td>Parity</td><td>1 bit</td><td><span class="code">0x1</span></td></tr>
    <tr><td>CRC-15-CAN</td><td>15 bits</td><td><span class="code">0x4599</span></td><td class="note">CAN-Bus</td></tr>
    <tr><td>CRC-16-IBM</td><td>16 bits</td><td><span class="code">0x8005</span></td><td class="note">Modbus, etc.</td></tr>
    <tr><td>CRC-17-CAN</td><td>17 bits</td><td><span class="code">0x1685b</span></td><td class="note">CAN FD, for messages &le; 16 bytes</td></tr>
    <tr><td>CRC-17-CAN</td><td>21 bits</td><td><span class="code">0x102899</span></td><td class="note">CAN FD, for messages &gt; 16 bytes</td></tr>
    <tr><td>CRC-32</td><td>32 bits</td><td><span class="code">0x04c11db7</span></td><td class="note">Ethernet, etc.</td></tr>
  </table>

  <p>
    <a href="http://users.ece.cmu.edu/~koopman/crc/index.html">Philip Koopman's page</a> provides tables of the "best" polynomials.
    His page also has links to other good references.
  </p>
</div>

<script>
  const CHAR_SPACE = " ".charCodeAt(0);
  const CHAR_ZERO = "0".charCodeAt(0);
  const CHAR_ONE = "1".charCodeAt(0);
  const CHAR_LOWERCASE_A = "a".charCodeAt(0);
  const CHAR_UPPERCASE_A = "A".charCodeAt(0);

  function hex_string_to_bits(string) {
    string = string.trim();

    if (string.slice(0, 2) == "0x") {
      string = string.slice(2);
    }

    let bits = [];
    for (let i = 0; i < string.length; ++i) {
      let c = string.charCodeAt(i);
      let digit = null;
      if (c == CHAR_SPACE) {
        // Ok
      } else if (CHAR_ZERO <= c && c <= CHAR_ZERO + 9) {
        digit = c - CHAR_ZERO;
      } else if (CHAR_LOWERCASE_A <= c && c <= CHAR_LOWERCASE_A + 5) {
        digit = c - CHAR_LOWERCASE_A + 10;
      } else if (CHAR_UPPERCASE_A <= c && c <= CHAR_UPPERCASE_A + 5) {
        digit = c - CHAR_UPPERCASE_A + 10;
      } else {
        bits = null;
        break;
      }

      bits.push((digit >> 3) & 1);
      bits.push((digit >> 2) & 1);
      bits.push((digit >> 1) & 1);
      bits.push((digit >> 0) & 1);
    }

    if (bits && bits.length == 0) {
      bits = null;
    }
    return bits;
  }

  const HEX_CHARACTERS = "0123456789abcdef";
  function bits_to_hex_string(bits) {
    let hex_string = "";
    for (let i = 0; i < bits.length; i += 4) {
      let digit = 0;
      for (let j = 0; j < 4 && i + j < bits.length; ++j) {
        let bit = bits[bits.length - (j + i) - 1];
        digit |= bit << j;
      }
      hex_string = HEX_CHARACTERS[digit] + hex_string;
    }
    if (hex_string.length == 0) {
      hex_string = 0;
    }
    return "0x" + hex_string;
  }



  let field_normal = document.getElementById("field_normal");
  let field_reverse = document.getElementById("field_reverse");
  let field_reciprocal = document.getElementById("field_reciprocal");
  let field_width = document.getElementById("field_width");
  let span_polynomial = document.getElementById("span_polynomial");
  let span_polynomial_degree = document.getElementById("span_polynomial_degree");
  let span_crc_width = document.getElementById("span_crc_width");


  let g_polynomial = null;

  function polynomial_update(field) {
    field_normal.classList.remove("bad");
    field_reverse.classList.remove("bad");
    field_reciprocal.classList.remove("bad");
    field_width.classList.remove("bad");

    // Normal variants, prepend MSB 1
    if (field == field_normal || field == field_width) {
      g_polynomial = hex_string_to_bits(field_normal.value);
      if (!g_polynomial) field.classList.add("bad");
    }
    if (g_polynomial && (field == field_normal || field == field_width)) {
      while (g_polynomial && g_polynomial.length > 1 && g_polynomial[0] == 0) {
        g_polynomial = g_polynomial.slice(1);
      }

      let width = parseInt(field_width.value);
      if (g_polynomial.length <= width) {
        let target_length = width + 1;
        let prefix = Array(target_length - g_polynomial.length).fill(0);
        prefix[0] = 1;
        g_polynomial = prefix.concat(g_polynomial);
      } else {
        g_polynomial = null;
        field_normal.classList.add("bad");
        field_width.classList.add("bad");
      }
    }

    // Reverse variants
    if (field == field_reverse) {
      g_polynomial = hex_string_to_bits(field_reverse.value);
      if (!g_polynomial) field_reverse.classList.add("bad");
    }
    if (g_polynomial && field == field_reverse) {
      field_width.value = g_polynomial.length;
      g_polynomial = g_polynomial.concat([1]);
      g_polynomial.reverse();
    }

    // Reciprocal variants
    if (field == field_reciprocal) {
      g_polynomial = hex_string_to_bits(field_reciprocal.value);
      if (!g_polynomial) field_reciprocal.classList.add("bad");
    }
    if (g_polynomial && field == field_reciprocal) {
      while (g_polynomial.length > 1 && g_polynomial[0] == 0) {
        g_polynomial = g_polynomial.slice(1);
      }
      field_width.value = g_polynomial.length;
      g_polynomial = g_polynomial.concat([1]);
    }

    // Update other fields
    if (g_polynomial) {
      if (field != field_normal) {
        field_normal.value = bits_to_hex_string(g_polynomial.slice(1));
      }
      if (field != field_reverse) {
        field_reverse.value = bits_to_hex_string(Array.from(g_polynomial.slice(1)).reverse());
      }
      if (field != field_reciprocal) {
        field_reciprocal.value = bits_to_hex_string(g_polynomial.slice(0, g_polynomial.length - 1));
      }

      let poly_string = "";
      for (let i = 0; i < g_polynomial.length; ++i) {
        if (g_polynomial[i]) {
          if (poly_string.length > 0) {
            poly_string += " + ";
          }
          if (i + 2 == g_polynomial.length) {
            poly_string += "x";
          } else if (i + 1 == g_polynomial.length) {
            poly_string += "1";
          } else {
            poly_string += "x<sup>" + (g_polynomial.length - i - 1) + "</sup>";
          }
        }
      }

      span_polynomial.innerHTML = poly_string;
      span_polynomial_degree.innerText = g_polynomial.length;
      span_crc_width.innerText = g_polynomial.length - 1;
    }
  }


  field_normal.oninput = function() { polynomial_update(field_normal); };
  field_reverse.oninput = function() { polynomial_update(field_reverse); };
  field_reciprocal.oninput = function() { polynomial_update(field_reciprocal); };
  field_width.oninput = function() { polynomial_update(field_width); };


  function common_polynomial_click() {
    let bits = parseInt(this.children[1].innerText.split(" ")[0]);
    let hex = this.children[2].children[0].innerText;
    field_width.value = bits;
    field_normal.value = hex;
    polynomial_update(field_normal);
  }

  let common_polynomials = document.getElementById("table_common_polynomials").children[0].children;
  for (let i = 0; i < common_polynomials.length; ++i) {
    let row = common_polynomials[i];
    row.onclick = common_polynomial_click;
  }

  common_polynomials[common_polynomials.length - 1].onclick();

</script>

</body>
</html>
